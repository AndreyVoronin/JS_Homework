ПЛАН 26-ГО УРОКА:
Разбор приложения.

Модульная разработка в Node.js:
  - Нужна, когда начинается работа с несколькими смысловыми сущностями, например пользователи, товары, заказы и т.д.
  - Папка database:
    - Файл-таблица базы данных tasks.json вынесен теперь в данную отдельную папку
  - Папка config:
    - Добавился новый npm-модуль config, используемый для хранения различных настроек, переменных окружения, путей к
      файлам и т.д., для удобного доступа к ним со всего сервера и с целью избегания дублирования кода
    - В данной папке хранится default.json файл с путями к различным файлам сервера (название папки и файла должны быть
      именно такими - для корректной работы модуля)
    - Для получения пути из файла default.json необходимо использовать метод config.get('имя свойства')
  - Папка routes:
    - Логика работы API разных сущностей разбивается на отдельные файлы и выносится в данную папку
    - server.js файл теперь подтягивает эти API-части через require() внутри app.use() и подключает в себя только те
      библиотеки, которые используются на уровне всего сервера
    - Файлы с частями API в свою очередь работают теперь с express.Router() и командой module.exports, и подключают в
      себя библиотеки, которые необходимы этому конкретному файлу-роуту

Сборщик WebPack:
  - Структура и основные понятия - http://dev-city.me/webpack-osnovnye-ponyatiya
  - Для работы с WebPack-ом понадобятся файлы webpack.config.js, package.json и, соответственно, npm-модули в папке
    frontend

  При использовании Git - стоит добавить в .gitignore папки node_modules (!!!), dist и файл package-lock.json

  Разворачивание WebPack:
    - Понадобится установленный Node.js для работы с npm-модулями
    - Перейти в папку 'frontend' проекта в консоли
    - Выполнить команду 'npm i' (установка необходимых модулей)
    - Для запуска сборщика:
      - в режиме разработки - использовать команду 'npm start'
      - в режиме production - использовать команду 'npm run build'
    - Сервер запускается как и раньше, через папку 'api', в отдельной консоли

    Доп. инфо *:
    - Для установки отдельного npm-модуля:
      - Ищем нужный модуль на сайте https://www.npmjs.com/, выбираем по необходимым опциям и кол-ву недельных скачиваний
      - Используем команду 'npm i имя-модуля --save', где флаг --save отвечает за сохранение информации об установленном
        пакете в файл package.json, а именно в раздел dependencies - зависимости, необходимые и в режиме разработки, и в
        продакшн-режиме
      - Используем команду 'npm i имя-модуля --save-dev', где флаг --save-dev отвечает за сохранение информации об
        установленном пакете в файл package.json, а именно в раздел devDependencies - зависимости, необходимые в режиме
        разработки
      - Использовать данные флаги необходимо всегда, для того, чтоб другие разработчики имели возможность устанавливать
        все необходимые модули за раз с помощью команды 'npm i', которая и считывает информацию из package.json файла

  Используемые модули, преобразования и фичи:
    Общие фичи WebPack:
      - Output по-умолчанию генерирует js-бандл (output-файл) в папку с названием dist
      - Resolve.extensions принимает в себя массив расширений файлов, с помощью него теперь в командах import можно не
        прописывать указанные расширения
      - Модули 'webpack' и 'webpack-cli' - нужны непосредственно для работы с WP
      - Модуль 'webpack-dev-server':
        - Необходим для запуска локального веб-сервера для фронтенд-части приложения вместо программы Fenix
        - В webpack.config.js (далее "конфиг") в опции devServer указывается нужный порт и опция open для
          автоматического запуска браузера при запуске сервера
        - При запуске сервера папка dist будет пустая, поскольку WDS работает с файлами в своей собственной памяти
        - По-умолчанию у сервера включена опция Live Reload - автоматическая перезагрузка страницы при изменении любого
          из модулей (например, js или less-файла)
        - Если указать опцию hot в опции devServer, добавить специальный плагин в конфиг и настройку в app.js
          файл - включится опция Hot Module Replacement - автоматическая перезагрузка только лишь измененного модуля и
          его зависимостей без перезагрузки страницы
      - Модуль 'clean-webpack-plugin' используется для очищения папки dist перед сборкой проекта
      - (!!!) Лоадеры не импортируются в конфиг, только плагины
      - (!!!) Exclude в каждом rules указывает в каких файлах и директориях не осуществлять поиск файлов с расширением
        из test

    Работа с JS:
      - Модули '@babel/core', '@babel/preset-env' и 'babel-loader' используются для транспиляции JS-кода версии ES6 в
        версию ES5
      - Модули 'eslint' и 'eslint-loader':
        - Используются для проверки грамотности и стиля JS-кода
        - Понадобится файл с настройками линтера в папке frontend - .eslintrc.json
        - В разделе rules в конфиге линтера в каждой опции указывается число от 0 до 2:
          - 0 означает, что проверка данного параметра временно отключена, но она нам еще понадобится в будущем
          - 1 означает, что проверка не строгая и при возникновении ошибки по данному параметру будет выводиться
            warning - желтое сообщение
          - 2 означает, что проверка строгая и при возникновении ошибки по данному параметру будет выводиться
            error - красное сообщение
        - Подробнее о настройках - http://www.zsoltnagy.eu/use-eslint-like-a-pro-with-es6-and-react/
        - Ошибки будут отображаться в консоли, где запущен WDS и в консоли браузера
        - Даже при наличии красных ошибок в консоли браузера - код все равно будет работать
        - Для наглядности работы линтера имеет смысл настроить его в WebStorm-е - File -> Settings ->
          ESLint (в поиске) -> выбрать Enable -> Проверить путь к модулю eslint (как правило, определяется автоматически)
      - (!!!) WebPack всегда запускает лоадеры снизу вверх, поэтому сначала прописывается ESLint, а затем Babel
      - Модуль 'uglifyjs-webpack-plugin' используется как плагин в опции конфига optimization.minimizer,
        для минификации JS-файлов
      - Source Maps:
        - Необходимо указать опцию devtool: 'source-map' для того, чтобы при генерации бандлов генерировались и их
          source-maps
        - .js.map - это своего рода файл-карта, хранящий пути к исходным отдельным и неминифицированным файлам (в режиме
          разработки с помощью WDS файл так же невидим, поскольку хранится в папке dist в памяти WDS)
        - Эти файлы доступны для дебаггинга через DevTools, вкладка Sources -> Ctrl + P

    Работа с LESS:
      - LESS-файл теперь необходимо подключать в app.js через import
      - Модули 'less' и 'less-loader' используются для компиляции LESS-кода в CSS
      - Модули 'postcss-loader' и 'autoprefixer' используются для добавления префиксов в CSS-код, для корректной работы
        также необходимо добавитьf в package.json файл опцию browserslist
      - Модуль 'css-loader' используется для транспиляции CSS-кода в JS-код, понятный WebPack-у
      - Модуль 'mini-css-extract-plugin' используется для преобразования JS-строк назад в CSS-код и также для сборки
        всех CSS-файлов в один бандл
      - (!!!) WebPack всегда запускает лоадеры снизу вверх, поэтому должна использоваться именно такая их последовательность
      - Модуль 'optimize-css-assets-webpack-plugin' используется как плагин в опции конфига optimization.minimizer,
        для минификации CSS-файлов

    Работа с HTML:
      - Модуль 'html-webpack-plugin' используется для генерации html-бандла в папке dist и для минификации html-файлов,
        при работе с данным модулем из исходного html-файла стоит удалить все подключения JS и CSS кода, поскольку
        модуль добавит их самостоятельно

    Работа с темплейтами:
      - Модули 'handlebars' и 'handlebars-loader' используются для работы с темплейтами в формате .hbs
      - Появилась папка templates
      - Темплейт теперь импортируется в JS-файл и вызывается как функция с передачей объекта с переменными, используемыми
        в темплейте, например myTemplate({name: 'Vasya'})
      - Темплейты можно импортировать друг в друга по имени и пути
      - В темплейтах можно использовать встроенные и кастомные хэлперы

  Доступные преобразования и фичи:
    В режиме разработки:
      - WDS и Hot Module Replacement
      - Babel
      - ESLint
      - LESS-to-CSS и префиксы
      - Темплейты
      - Минификация HTML
      - Очищение папки dist
      - Source Maps
      - Resolve расширений файлов

    В режиме production:
      - Запуск клиентской части приложения должен осуществляться через программу Fenix (указывать путь к папке dist)
      - Babel
      - ESLint
      - Минификация JS
      - LESS-to-CSS, префиксы и минификация
      - Темплейты
      - Минификация HTML
      - Очищение папки dist
      - Resolve расширений файлов