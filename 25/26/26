ПЛАН 26-ГО УРОКА:
Разбор приложения.

Модульная разработка в Node.js:
  - Нужна, когда начинается работа с несколькими смысловыми сущностями, например пользователи, товары, заказы и т.д.
  - Логика работы API отдельных сущностей выносится в отдельные файлы в папку routes
  - server.js файл теперь подтягивает эти API-части через require() внутри app.use()
  - Файлы в свою очередь работают теперь с express.Router()
  - Файл-таблица базы данных tasks.json вынесен в отдельную папку data
  - Добавился новый npm-модуль config, в папке config хранится default.json файл с путями к "таблицам" нашей
    импровизированной базы данных

Сборщик WebPack:
  - Структура и основные понятия - http://dev-city.me/webpack-osnovnye-ponyatiya
  - Для работы с WebPack-ом понадобятся файлы webpack.config.js, package.json и, соответственно, npm-модули

  При использовании Git - стоит добавить в .gitignore папки node_modules (!!!), dist и файл package-lock.json

  Разворачивание WebPack:
    - Понадобится установленный Node.js для работы с npm-модулями
    - Перейти в папку 'frontend' проекта в консоли
    - Выполнить команду 'npm i' (установка необходимых модулей)
    - Для запуска сборщика:
      - в режиме разработки - использовать команду 'npm start'
      - в режиме production - использовать команду 'npm run build'
    - Сервер запускается как и раньше, через папку 'api', в отдельной консоли

    Доп. инфо *:
    - Для установки отдельного npm-модуля:
      - Ищем нужный модуль на сайте https://www.npmjs.com/, выбираем по необходимым опциям и кол-ву недельных скачиваний
      - Используем команду 'npm i имя-модуля --save', где флаг --save отвечает за сохранение информации об установленном
        пакете в файл package.json, а именно в раздел dependencies - зависимости, необходимые и в режиме разработки, и в
        продакшн-режиме
      - Используем команду 'npm i имя-модуля --save-dev', где флаг --save-dev отвечает за сохранение информации об
        установленном пакете в файл package.json, а именно в раздел devDependencies - зависимости, необходимые в режиме
        разработки
      - Использовать данные флаги необходимо всегда, для того, чтоб другие разработчики имели возможность устанавливать
        все необходимые модули за раз с помощью команды 'npm i', которая и считывает информацию из package.json файла

  Используемые модули, преобразования и фичи:
    Работа с WebPack:
      - Модули 'webpack' и 'webpack-cli' - нужны непосредственно для работы с WP
      - Модуль 'webpack-dev-server':
        - Необходим для запуска локального веб-сервера для фронтенд-части приложения вместо программы Fenix
        - В webpack.config.js (далее "конфиг") в опции devServer указывается нужный порт и опция open для
          автоматического запуска браузера при запуске сервера
        - При запуске сервера папка dist будет пустая, поскольку WDS работает с файлами в своей собственной памяти
        - По-умолчанию у сервера включена опция Live Reload - автоматическая перезагрузка страницы при изменении любого
          из модулей (например, js или less-файла)
        - Если указать опцию hot в опции devServer, добавить специальный плагин в конфиг и настройку в app.js
          файл - включится опция Hot Module Replacement - автоматическая перезагрузка не всей страницы, а только
          измененного модуля и его зависимостей

    Работа с JS:
      - Модули '@babel/core', '@babel/preset-env' и 'babel-loader' используются для транспиляции JS-кода версии ES6 в
        версию ES5
      - Модули 'eslint' и 'eslint-loader':
        - Используются для проверки грамотности и стиля JS-кода
        - Понадобится файл с настройками линтера - .eslintrc.json
        - Подробнее о настройках - http://www.zsoltnagy.eu/use-eslint-like-a-pro-with-es6-and-react/
        - Для наглядности работы линтера имеет смысл настроить его в WebStorm-е - File -> Settings -> ESLint (в поиске) ->
          выбрать Enable -> Проверить путь к модулю eslint (как правило, определяется автоматически)
        - Ошибки будут также отображаться в консоли, где запущен WDS и в консоли браузера
        - Даже при наличии красных ошибок в консоли браузера - код все равно будет работать
      - !!! WebPack всегда запускает лоадеры снизу вверх, поэтому сначала прописывается ESLint, а затем Babel
      - Модуль 'uglifyjs-webpack-plugin' используется как плагин в опции конфига optimization.minimizer,
        для минификации JS-файлов

    Работа с LESS:
      - LESS-файл теперь необходимо подключать в app.js через import
      - Модули 'less' и 'less-loader' используются для компиляции LESS-кода в CSS
      - Модули 'postcss-loader' и 'autoprefixer' используются для добавления префиксов в CSS-код, для корректной работы
        также необходимо добавитьf в package.json файл опцию browserslist
      - Модуль 'css-loader' используется для транспиляции CSS-кода в JS-код, понятный WebPack-у
      - Модуль 'mini-css-extract-plugin' используется для преобразования JS-строк назад в CSS-код и также для сборки
        всех CSS-файлов в один бандл (output-файл)
      - !!! WebPack всегда запускает лоадеры снизу вверх, поэтому должна использоваться именно такая их последовательность
      - Модуль 'optimize-css-assets-webpack-plugin' используется как плагин в опции конфига optimization.minimizer,
        для минификации CSS-файлов

    Работа с темплейтами:
      - Модули 'handlebars' и 'handlebars-loader' используются для работы с темплейтами в формате .hbs
      - Появилась папка templates
      - Темплейт теперь импортируется в JS-файл и вызывается как функция с передачей объекта с переменными, используемыми
        в темплейте, например myTemplate({name: 'Vasya'})
      - Темплейты можно импортировать друг в друга по имени и пути
      - В темплейтах можно использовать встроенные и кастомные хэлперы

    Работа с HTML:
      - Модуль 'html-webpack-plugin' используется для генерации html-бандла в папке dist и для минификации html-файлов,
        при работе с данным модулем из исходного html-файла стоит удалить все подключения JS и CSS кода, поскольку
        модуль добавит их самостоятельно

    Доп. опции webpack.config.js:
      - Output по-умолчанию генерирует js-бандл в папку с названием dist
      - Модуль 'clean-webpack-plugin' используется для очищения папки dist перед сборкой проекта
      - Source Maps:
        - Необходимо указать опцию devtool: 'source-map' для того, чтобы при генерации бандлов генерировались и их
          source-maps
        - .js.map - это своего рода файл-карта, хранящий пути к исходным отдельным и неминифицированным файлам
        - Эти файлы доступны для дебаггинга через DevTools, вкладка Sources -> Ctrl + P
      - Resolve.extensions принимает в себя массив расширений файлов, с помощью него теперь в командах import можно не
        прописывать указанные расширения
      - Exclude в каждом rules указывает в каких файлах и директориях не осуществлять поиск файлов с расширением из test

  Доступные преобразования и фичи:
    В режиме разработки:
      - WDS и Hot Module Replacement
      - Babel
      - ESLint
      - LESS-to-CSS и префиксы
      - Темплейты
      - Минификация HTML
      - Очищение папки dist
      - Source Maps
      - Resolve расширений файлов

    В режиме production:
      - Запуск клиентской части приложения должен осуществляться через программу Fenix (указывать путь к папке dist)
      - Babel
      - ESLint
      - Минификация JS
      - LESS-to-CSS, префиксы и минификация
      - Темплейты
      - Минификация HTML
      - Очищение папки dist
      - Source Maps
      - Resolve расширений файлов

Тесты:
  - Виды тестов:
    - Acceptance-тесты - тестирование системы в целом, например, перейти на такую-то страницу, ввести запрос в поле
      поиска, убедиться что отобразились новые блоки с искомой информацией
    - Unit-тесты - тестирование отдельного модуля (одного файла), например тестирование работы методов класса
    - Integration-тесты - тестирование взаимодействия нескольких модулей сразу
  - Пример синтаксиса и написания тестов - https://learn.javascript.ru/testing-mocha
  - Виды туллзов для тестирования:
    - Непосредственно фреймворки для написания тестов
    - Assertion библиотеки
    - Библиотеки для определения степени покрытия приложения тестами

Доп. инфо:
  - React.js/Redux:
    - Простой учебник-туториал по React.js - см. материалы
    - Наглядная статья по общим концепциям Redux - https://iamakulov.com/talks/redux-in-real-life/
    - Учебник-туториал по Redux - см. материалы
    - Потенциальные вопросы на собеседовании - см. памятку
  - Для будущей работы имеет смысл научиться устанавливать виртуальную машину на Ubuntu